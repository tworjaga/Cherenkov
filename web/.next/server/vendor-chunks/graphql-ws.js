"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-ws";
exports.ids = ["vendor-chunks/graphql-ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphql-ws/lib/client.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/client.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType),\n/* harmony export */   TerminatedCloseEvent: () => (/* binding */ TerminatedCloseEvent),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.isMessage),\n/* harmony export */   parseMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage),\n/* harmony export */   stringifyMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage),\n/* harmony export */   validateMessage: () => (/* reexport safe */ _common_mjs__WEBPACK_IMPORTED_MODULE_0__.validateMessage)\n/* harmony export */ });\n/* harmony import */ var _common_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/common.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * client\n *\n */ var __await = undefined && undefined.__await || function(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator = undefined && undefined.__asyncGenerator || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\n\n\n/** This file is the entry point for browsers, re-export common elements. */ \n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */ function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for(let i = 0; i < retries; i++){\n            retryDelay *= 2;\n        }\n        await new Promise((resolve)=>setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */ generateID = function generateUUID() {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n            const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error(\"Invalid WebSocket implementation provided\");\n        }\n        ws = webSocketImpl;\n    } else if (typeof WebSocket !== \"undefined\") {\n        ws = WebSocket;\n    } else if (typeof global !== \"undefined\") {\n        ws = global.WebSocket || // @ts-expect-error: Support more browsers\n        global.MozWebSocket;\n    } else if (false) {}\n    if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (()=>{\n        const message = (()=>{\n            const listeners = {};\n            return {\n                on (id, listener) {\n                    listeners[id] = listener;\n                    return ()=>{\n                        delete listeners[id];\n                    };\n                },\n                emit (message) {\n                    var _a;\n                    if (\"id\" in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                }\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [\n                on.connecting\n            ] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [\n                on.opened\n            ] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [\n                on.connected\n            ] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [\n                on.ping\n            ] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [\n                on.pong\n            ] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [\n                message.emit,\n                on.message\n            ] : [\n                message.emit\n            ],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [\n                on.closed\n            ] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [\n                on.error\n            ] : []\n        };\n        return {\n            onMessage: message.on,\n            on (event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return ()=>{\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit (event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [\n                    ...listeners[event]\n                ]){\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            }\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on(\"error\", (err)=>{\n                listening.forEach((unlisten)=>unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on(\"closed\", (event)=>{\n                listening.forEach((unlisten)=>unlisten());\n                cb(event);\n            })\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied)=>(async ()=>{\n                if (retrying) {\n                    await retryWait(retries);\n                    // subscriptions might complete while waiting for retry\n                    if (!locks) {\n                        connecting = undefined;\n                        return denied({\n                            code: 1000,\n                            reason: \"All Subscriptions Gone\"\n                        });\n                    }\n                    retries++;\n                }\n                emitter.emit(\"connecting\", retrying);\n                const socket = new WebSocketImpl(typeof url === \"function\" ? await url() : url, _common_mjs__WEBPACK_IMPORTED_MODULE_0__.GRAPHQL_TRANSPORT_WS_PROTOCOL);\n                let connectionAckTimeout, queuedPing;\n                function enqueuePing() {\n                    if (isFinite(keepAlive) && keepAlive > 0) {\n                        clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                        queuedPing = setTimeout(()=>{\n                            if (socket.readyState === WebSocketImpl.OPEN) {\n                                socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping\n                                }));\n                                emitter.emit(\"ping\", false, undefined);\n                            }\n                        }, keepAlive);\n                    }\n                }\n                errorOrClosed((errOrEvent)=>{\n                    connecting = undefined;\n                    clearTimeout(connectionAckTimeout);\n                    clearTimeout(queuedPing);\n                    denied(errOrEvent);\n                    if (errOrEvent instanceof TerminatedCloseEvent) {\n                        socket.close(4499, \"Terminated\"); // close event is artificial and emitted manually, see `Client.terminate()` below\n                        socket.onerror = null;\n                        socket.onclose = null;\n                    }\n                });\n                socket.onerror = (err)=>emitter.emit(\"error\", err);\n                socket.onclose = (event)=>emitter.emit(\"closed\", event);\n                socket.onopen = async ()=>{\n                    try {\n                        emitter.emit(\"opened\", socket);\n                        const payload = typeof connectionParams === \"function\" ? await connectionParams() : connectionParams;\n                        // connectionParams might take too long causing the server to kick off the client\n                        // the necessary error/close event is already reported - simply stop execution\n                        if (socket.readyState !== WebSocketImpl.OPEN) return;\n                        socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(payload ? {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit,\n                            payload\n                        } : {\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionInit\n                        }, replacer));\n                        if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n                            connectionAckTimeout = setTimeout(()=>{\n                                socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.ConnectionAcknowledgementTimeout, \"Connection acknowledgement timeout\");\n                            }, connectionAckWaitTimeout);\n                        }\n                        enqueuePing(); // enqueue ping (noop if disabled)\n                    } catch (err) {\n                        emitter.emit(\"error\", err);\n                        socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, \"Internal client error\"));\n                    }\n                };\n                let acknowledged = false;\n                socket.onmessage = ({ data })=>{\n                    try {\n                        const message = (0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.parseMessage)(data, reviver);\n                        emitter.emit(\"message\", message);\n                        if (message.type === \"ping\" || message.type === \"pong\") {\n                            emitter.emit(message.type, true, message.payload); // received\n                            if (message.type === \"pong\") {\n                                enqueuePing(); // enqueue next ping (noop if disabled)\n                            } else if (!disablePong) {\n                                // respond with pong on ping\n                                socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)(message.payload ? {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong,\n                                    payload: message.payload\n                                } : {\n                                    type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Pong\n                                }));\n                                emitter.emit(\"pong\", false, message.payload);\n                            }\n                            return; // ping and pongs can be received whenever\n                        }\n                        if (acknowledged) return; // already connected and acknowledged\n                        if (message.type !== _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n                        clearTimeout(connectionAckTimeout);\n                        acknowledged = true;\n                        emitter.emit(\"connected\", socket, message.payload, retrying); // connected = socket opened + acknowledged\n                        retrying = false; // future lazy connects are not retries\n                        retries = 0; // reset the retries on connect\n                        connected([\n                            socket,\n                            new Promise((_, reject)=>errorOrClosed(reject))\n                        ]);\n                    } catch (err) {\n                        socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                        emitter.emit(\"error\", err);\n                        socket.close(_common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse, (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.limitCloseReason)(err instanceof Error ? err.message : new Error(err).message, \"Bad response\"));\n                    }\n                };\n            })()));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n        let release = ()=>{\n        // releases this connection\n        };\n        const released = new Promise((resolve)=>release = resolve);\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(()=>{\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = ()=>socket.close(1000, \"Normal Closure\");\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(()=>{\n                                if (socket.readyState === WebSocketImpl.OPEN) complete();\n                            }, lazyCloseTimeoutMs);\n                        } else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose\n            ])\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */ function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalServerError,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.InternalClientError,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadRequest,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.BadResponse,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.Unauthorized,\n            // CloseCode.Forbidden, might grant access out after retry\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubprotocolNotAcceptable,\n            // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n            // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.SubscriberAlreadyExists,\n            _common_mjs__WEBPACK_IMPORTED_MODULE_0__.CloseCode.TooManyInitialisationRequests\n        ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed) return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n        // looks good, start retrying\n        return retrying = true;\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async ()=>{\n            locks++;\n            for(;;){\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                } catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n                    } catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = ()=>{\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async ()=>{\n            locks++;\n            for(;;){\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done) return release();\n                    const unlisten = emitter.onMessage(id, (message)=>{\n                        switch(message.type){\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Next:\n                                {\n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                    sink.next(message.payload);\n                                    return;\n                                }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Error:\n                                {\n                                    errored = true, done = true;\n                                    sink.error(message.payload);\n                                    releaser();\n                                    return;\n                                }\n                            case _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete:\n                                {\n                                    done = true;\n                                    releaser(); // release completes the sink\n                                    return;\n                                }\n                        }\n                    });\n                    socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                        id,\n                        type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Subscribe,\n                        payload\n                    }, replacer));\n                    releaser = ()=>{\n                        if (!done && socket.readyState === WebSocketImpl.OPEN) // if not completed already and socket is open, send complete message to server on release\n                        socket.send((0,_common_mjs__WEBPACK_IMPORTED_MODULE_0__.stringifyMessage)({\n                            id,\n                            type: _common_mjs__WEBPACK_IMPORTED_MODULE_0__.MessageType.Complete\n                        }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                } catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n                }\n            }\n        })().then(()=>{\n            // delivering either an error or a complete terminates the sequence\n            if (!errored) sink.complete();\n        }) // resolves on release or normal closure\n        .catch((err)=>{\n            sink.error(err);\n        }); // rejects on close events and errors\n        return ()=>{\n            // dispose only of active subscriptions\n            if (!done) releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate (request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: ()=>{\n                // noop\n                }\n            };\n            const dispose = subscribe(request, {\n                next (val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error (err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete () {\n                    deferred.done = true;\n                    deferred.resolve();\n                }\n            });\n            const iterator = function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for(;;){\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve)=>deferred.resolve = resolve));\n                        }\n                        // first flush\n                        while(pending.length){\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            }();\n            iterator.throw = async (err)=>{\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return {\n                    done: true,\n                    value: undefined\n                };\n            };\n            iterator.return = async ()=>{\n                dispose();\n                return {\n                    done: true,\n                    value: undefined\n                };\n            };\n            return iterator;\n        },\n        async dispose () {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, \"Normal Closure\");\n            }\n        },\n        terminate () {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit(\"closed\", new TerminatedCloseEvent());\n            }\n        }\n    };\n}\n/**\n * A synthetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */ class TerminatedCloseEvent extends Error {\n    constructor(){\n        super(...arguments);\n        this.name = \"TerminatedCloseEvent\";\n        this.message = \"4499: Terminated\";\n        this.code = 4499;\n        this.reason = \"Terminated\";\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && \"code\" in val && \"reason\" in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1014\n    ].includes(code)) return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return typeof val === \"function\" && \"constructor\" in val && \"CLOSED\" in val && \"CLOSING\" in val && \"CONNECTING\" in val && \"OPEN\" in val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY2xpZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsSUFBSUEsVUFBVSxTQUFLLElBQUksU0FBSSxDQUFDQSxPQUFPLElBQUssU0FBVUMsQ0FBQztJQUFJLE9BQU8sSUFBSSxZQUFZRCxVQUFXLEtBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxHQUFHLElBQUksSUFBSSxJQUFJRCxRQUFRQztBQUFJO0FBQzdILElBQUlDLG1CQUFtQixTQUFLLElBQUksU0FBSSxDQUFDQSxnQkFBZ0IsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsU0FBUztJQUM5RixJQUFJLENBQUNDLE9BQU9DLGFBQWEsRUFBRSxNQUFNLElBQUlDLFVBQVU7SUFDL0MsSUFBSUMsSUFBSUosVUFBVUssS0FBSyxDQUFDUCxTQUFTQyxjQUFjLEVBQUUsR0FBR08sR0FBR0MsSUFBSSxFQUFFO0lBQzdELE9BQU9ELElBQUlFLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLE9BQU9DLGtCQUFrQixhQUFhQSxnQkFBZ0JGLE1BQUssRUFBR0csU0FBUyxHQUFHQyxLQUFLLFNBQVNBLEtBQUssVUFBVUEsS0FBSyxVQUFVQyxjQUFjUCxDQUFDLENBQUNMLE9BQU9DLGFBQWEsQ0FBQyxHQUFHO1FBQWMsT0FBTyxJQUFJO0lBQUUsR0FBR0k7SUFDdE4sU0FBU08sWUFBWUMsQ0FBQztRQUFJLE9BQU8sU0FBVWxCLENBQUM7WUFBSSxPQUFPbUIsUUFBUUMsT0FBTyxDQUFDcEIsR0FBR3FCLElBQUksQ0FBQ0gsR0FBR0k7UUFBUztJQUFHO0lBQzlGLFNBQVNOLEtBQUtPLENBQUMsRUFBRUwsQ0FBQztRQUFJLElBQUlWLENBQUMsQ0FBQ2UsRUFBRSxFQUFFO1lBQUViLENBQUMsQ0FBQ2EsRUFBRSxHQUFHLFNBQVV2QixDQUFDO2dCQUFJLE9BQU8sSUFBSW1CLFFBQVEsU0FBVUssQ0FBQyxFQUFFQyxDQUFDO29C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c0M7SUFDdEMsT0FBT0EsUUFBUSxRQUFRQSxRQUFRO0FBQ25DO0FBQ0EsU0FBUzFDLFlBQVlzRyxHQUFHO0lBQ3BCLE9BQVEsT0FBT0EsUUFBUSxjQUNuQixpQkFBaUJBLE9BQ2pCLFlBQVlBLE9BQ1osYUFBYUEsT0FDYixnQkFBZ0JBLE9BQ2hCLFVBQVVBO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hlcmVua292LXdlYi8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jbGllbnQubWpzP2FiOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY2xpZW50XG4gKlxuICovXG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuaW1wb3J0IHsgQ2xvc2VDb2RlLCBHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCwgTWVzc2FnZVR5cGUsIHBhcnNlTWVzc2FnZSwgc3RyaW5naWZ5TWVzc2FnZSwgfSBmcm9tICcuL2NvbW1vbi5tanMnO1xuaW1wb3J0IHsgaXNPYmplY3QsIGxpbWl0Q2xvc2VSZWFzb24gfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKiogVGhpcyBmaWxlIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYnJvd3NlcnMsIHJlLWV4cG9ydCBjb21tb24gZWxlbWVudHMuICovXG5leHBvcnQgKiBmcm9tICcuL2NvbW1vbi5tanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGlzcG9zYWJsZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2xpZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGllbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXJsLCBjb25uZWN0aW9uUGFyYW1zLCBsYXp5ID0gdHJ1ZSwgb25Ob25MYXp5RXJyb3IgPSBjb25zb2xlLmVycm9yLCBsYXp5Q2xvc2VUaW1lb3V0OiBsYXp5Q2xvc2VUaW1lb3V0TXMgPSAwLCBrZWVwQWxpdmUgPSAwLCBkaXNhYmxlUG9uZywgY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0ID0gMCwgcmV0cnlBdHRlbXB0cyA9IDUsIHJldHJ5V2FpdCA9IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbWlzZWRFeHBvbmVudGlhbEJhY2tvZmYocmV0cmllcykge1xuICAgICAgICBsZXQgcmV0cnlEZWxheSA9IDEwMDA7IC8vIHN0YXJ0IHdpdGggMXMgZGVsYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5ICtcbiAgICAgICAgICAgIC8vIGFkZCByYW5kb20gdGltZW91dCBmcm9tIDMwMG1zIHRvIDNzXG4gICAgICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMzAwMCAtIDMwMCkgKyAzMDApKSk7XG4gICAgfSwgc2hvdWxkUmV0cnkgPSBpc0xpa2VDbG9zZUV2ZW50LCBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0sIG9uLCB3ZWJTb2NrZXRJbXBsLCBcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB2NCBVVUlEIHRvIGJlIHVzZWQgYXMgdGhlIElEIHVzaW5nIGBNYXRoYFxuICAgICAqIGFzIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gU3VwcGx5IHlvdXIgb3duIGdlbmVyYXRvclxuICAgICAqIGluIGNhc2UgeW91IG5lZWQgbW9yZSB1bmlxdWVuZXNzLlxuICAgICAqXG4gICAgICogUmVmZXJlbmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG4gICAgICovXG4gICAgZ2VuZXJhdGVJRCA9IGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgICAgIH0pO1xuICAgIH0sIGpzb25NZXNzYWdlUmVwbGFjZXI6IHJlcGxhY2VyLCBqc29uTWVzc2FnZVJldml2ZXI6IHJldml2ZXIsIH0gPSBvcHRpb25zO1xuICAgIGxldCB3cztcbiAgICBpZiAod2ViU29ja2V0SW1wbCkge1xuICAgICAgICBpZiAoIWlzV2ViU29ja2V0KHdlYlNvY2tldEltcGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgd3MgPSB3ZWJTb2NrZXRJbXBsO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3cyA9IFdlYlNvY2tldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd3MgPVxuICAgICAgICAgICAgZ2xvYmFsLldlYlNvY2tldCB8fFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFN1cHBvcnQgbW9yZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdzID1cbiAgICAgICAgICAgIHdpbmRvdy5XZWJTb2NrZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBTdXBwb3J0IG1vcmUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICB3aW5kb3cuTW96V2ViU29ja2V0O1xuICAgIH1cbiAgICBpZiAoIXdzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaW1wbGVtZW50YXRpb24gbWlzc2luZzsgb24gTm9kZSB5b3UgY2FuIGBpbXBvcnQgV2ViU29ja2V0IGZyb20gJ3dzJztgIGFuZCBwYXNzIGB3ZWJTb2NrZXRJbXBsOiBXZWJTb2NrZXRgIHRvIGBjcmVhdGVDbGllbnRgXCIpO1xuICAgIGNvbnN0IFdlYlNvY2tldEltcGwgPSB3cztcbiAgICAvLyB3ZWJzb2NrZXQgc3RhdHVzIGVtaXR0ZXIsIHN1YnNjcmlwdGlvbnMgYXJlIGhhbmRsZWQgZGlmZmVyZW50bHlcbiAgICBjb25zdCBlbWl0dGVyID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb24oaWQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpZF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW1pdChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyc1ttZXNzYWdlLmlkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXJzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgY29ubmVjdGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5jb25uZWN0aW5nKSA/IFtvbi5jb25uZWN0aW5nXSA6IFtdLFxuICAgICAgICAgICAgb3BlbmVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLm9wZW5lZCkgPyBbb24ub3BlbmVkXSA6IFtdLFxuICAgICAgICAgICAgY29ubmVjdGVkOiAob24gPT09IG51bGwgfHwgb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uLmNvbm5lY3RlZCkgPyBbb24uY29ubmVjdGVkXSA6IFtdLFxuICAgICAgICAgICAgcGluZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5waW5nKSA/IFtvbi5waW5nXSA6IFtdLFxuICAgICAgICAgICAgcG9uZzogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5wb25nKSA/IFtvbi5wb25nXSA6IFtdLFxuICAgICAgICAgICAgbWVzc2FnZTogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5tZXNzYWdlKSA/IFttZXNzYWdlLmVtaXQsIG9uLm1lc3NhZ2VdIDogW21lc3NhZ2UuZW1pdF0sXG4gICAgICAgICAgICBjbG9zZWQ6IChvbiA9PT0gbnVsbCB8fCBvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb24uY2xvc2VkKSA/IFtvbi5jbG9zZWRdIDogW10sXG4gICAgICAgICAgICBlcnJvcjogKG9uID09PSBudWxsIHx8IG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbi5lcnJvcikgPyBbb24uZXJyb3JdIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvbk1lc3NhZ2U6IG1lc3NhZ2Uub24sXG4gICAgICAgICAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBsLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGwuc3BsaWNlKGwuaW5kZXhPZihsaXN0ZW5lciksIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNvcHkgdGhlIGxpc3RlbmVycyBzbyB0aGF0IHVubGlzdGVucyBkb250IFwicHVsbCB0aGUgcnVnIHVuZGVyIG91ciBmZWV0XCJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi5saXN0ZW5lcnNbZXZlbnRdXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUaGUgYXJncyBzaG91bGQgZml0XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvLyBpbnZva2VzIHRoZSBjYWxsYmFjayBlaXRoZXIgd2hlbiBhbiBlcnJvciBvciBjbG9zZWQgZXZlbnQgaXMgZW1pdHRlZCxcbiAgICAvLyBmaXJzdCBvbmUgdGhhdCBnZXRzIGNhbGxlZCBwcmV2YWlscywgb3RoZXIgZW1pc3Npb25zIGFyZSBpZ25vcmVkXG4gICAgZnVuY3Rpb24gZXJyb3JPckNsb3NlZChjYikge1xuICAgICAgICBjb25zdCBsaXN0ZW5pbmcgPSBbXG4gICAgICAgICAgICAvLyBlcnJvcnMgYXJlIGZhdGFsIGFuZCBtb3JlIGNyaXRpY2FsIHRoYW4gY2xvc2UgZXZlbnRzLCB0aHJvdyB0aGVtIGZpcnN0XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5pbmcuZm9yRWFjaCgodW5saXN0ZW4pID0+IHVubGlzdGVuKCkpO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIGNsb3NlcyBjYW4gYmUgZ3JhY2VmdWwgYW5kIG5vdCBmYXRhbCwgdGhyb3cgdGhlbSBzZWNvbmQgKGlmIGVycm9yIGRpZG50IHRocm93KVxuICAgICAgICAgICAgZW1pdHRlci5vbignY2xvc2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdGVuaW5nLmZvckVhY2goKHVubGlzdGVuKSA9PiB1bmxpc3RlbigpKTtcbiAgICAgICAgICAgICAgICBjYihldmVudCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGV0IGNvbm5lY3RpbmcsIGxvY2tzID0gMCwgbGF6eUNsb3NlVGltZW91dCwgcmV0cnlpbmcgPSBmYWxzZSwgcmV0cmllcyA9IDAsIGRpc3Bvc2VkID0gZmFsc2U7XG4gICAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGxhenkgY2xvc2UgdGltZW91dCBpbW1lZGlhdGVsbHkgc28gdGhhdCBjbG9zZSBnZXRzIGRlYm91bmNlZFxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9pc3N1ZXMvMzg4XG4gICAgICAgIGNsZWFyVGltZW91dChsYXp5Q2xvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3QgW3NvY2tldCwgdGhyb3dPbkNsb3NlXSA9IGF3YWl0IChjb25uZWN0aW5nICE9PSBudWxsICYmIGNvbm5lY3RpbmcgIT09IHZvaWQgMCA/IGNvbm5lY3RpbmcgOiAoY29ubmVjdGluZyA9IG5ldyBQcm9taXNlKChjb25uZWN0ZWQsIGRlbmllZCkgPT4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXRyeWluZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJldHJ5V2FpdChyZXRyaWVzKTtcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb25zIG1pZ2h0IGNvbXBsZXRlIHdoaWxlIHdhaXRpbmcgZm9yIHJldHJ5XG4gICAgICAgICAgICAgICAgaWYgKCFsb2Nrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVuaWVkKHsgY29kZTogMTAwMCwgcmVhc29uOiAnQWxsIFN1YnNjcmlwdGlvbnMgR29uZScgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnY29ubmVjdGluZycsIHJldHJ5aW5nKTtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXRJbXBsKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicgPyBhd2FpdCB1cmwoKSA6IHVybCwgR1JBUEhRTF9UUkFOU1BPUlRfV1NfUFJPVE9DT0wpO1xuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25BY2tUaW1lb3V0LCBxdWV1ZWRQaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gZW5xdWV1ZVBpbmcoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGtlZXBBbGl2ZSkgJiYga2VlcEFsaXZlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocXVldWVkUGluZyk7IC8vIGluIGNhc2Ugd2hlcmUgYSBwb25nIHdhcyByZWNlaXZlZCBiZWZvcmUgYSBwaW5nICh0aGlzIGlzIHZhbGlkIGJlaGF2aW91cilcbiAgICAgICAgICAgICAgICAgICAgcXVldWVkUGluZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXRJbXBsLk9QRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHsgdHlwZTogTWVzc2FnZVR5cGUuUGluZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwaW5nJywgZmFsc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGtlZXBBbGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JPckNsb3NlZCgoZXJyT3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25BY2tUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocXVldWVkUGluZyk7XG4gICAgICAgICAgICAgICAgZGVuaWVkKGVyck9yRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJPckV2ZW50IGluc3RhbmNlb2YgVGVybWluYXRlZENsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKDQ0OTksICdUZXJtaW5hdGVkJyk7IC8vIGNsb3NlIGV2ZW50IGlzIGFydGlmaWNpYWwgYW5kIGVtaXR0ZWQgbWFudWFsbHksIHNlZSBgQ2xpZW50LnRlcm1pbmF0ZSgpYCBiZWxvd1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNvY2tldC5vbmVycm9yID0gKGVycikgPT4gZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4gZW1pdHRlci5lbWl0KCdjbG9zZWQnLCBldmVudCk7XG4gICAgICAgICAgICBzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnb3BlbmVkJywgc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHR5cGVvZiBjb25uZWN0aW9uUGFyYW1zID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IGNvbm5lY3Rpb25QYXJhbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25uZWN0aW9uUGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uUGFyYW1zIG1pZ2h0IHRha2UgdG9vIGxvbmcgY2F1c2luZyB0aGUgc2VydmVyIHRvIGtpY2sgb2ZmIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5lY2Vzc2FyeSBlcnJvci9jbG9zZSBldmVudCBpcyBhbHJlYWR5IHJlcG9ydGVkIC0gc2ltcGx5IHN0b3AgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChzdHJpbmdpZnlNZXNzYWdlKHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkNvbm5lY3Rpb25Jbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXlsb2FkIGlzIGNvbXBsZXRlbHkgYWJzZW50IGlmIG5vdCBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25BY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5Db25uZWN0aW9uQWNrbm93bGVkZ2VtZW50VGltZW91dCwgJ0Nvbm5lY3Rpb24gYWNrbm93bGVkZ2VtZW50IHRpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbm5lY3Rpb25BY2tXYWl0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVBpbmcoKTsgLy8gZW5xdWV1ZSBwaW5nIChub29wIGlmIGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoQ2xvc2VDb2RlLkludGVybmFsQ2xpZW50RXJyb3IsIGxpbWl0Q2xvc2VSZWFzb24oZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IG5ldyBFcnJvcihlcnIpLm1lc3NhZ2UsICdJbnRlcm5hbCBjbGllbnQgZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY2tub3dsZWRnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gcGFyc2VNZXNzYWdlKGRhdGEsIHJldml2ZXIpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3BpbmcnIHx8IG1lc3NhZ2UudHlwZSA9PT0gJ3BvbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQobWVzc2FnZS50eXBlLCB0cnVlLCBtZXNzYWdlLnBheWxvYWQpOyAvLyByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ3BvbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVBpbmcoKTsgLy8gZW5xdWV1ZSBuZXh0IHBpbmcgKG5vb3AgaWYgZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZGlzYWJsZVBvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25kIHdpdGggcG9uZyBvbiBwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LnNlbmQoc3RyaW5naWZ5TWVzc2FnZShtZXNzYWdlLnBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5Qb25nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbWVzc2FnZS5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUG9uZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaXMgY29tcGxldGVseSBhYnNlbnQgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BvbmcnLCBmYWxzZSwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gcGluZyBhbmQgcG9uZ3MgY2FuIGJlIHJlY2VpdmVkIHdoZW5ldmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFja25vd2xlZGdlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBjb25uZWN0ZWQgYW5kIGFja25vd2xlZGdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9PSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uQWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaXJzdCBtZXNzYWdlIGNhbm5vdCBiZSBvZiB0eXBlICR7bWVzc2FnZS50eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvbkFja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBhY2tub3dsZWRnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nvbm5lY3RlZCcsIHNvY2tldCwgbWVzc2FnZS5wYXlsb2FkLCByZXRyeWluZyk7IC8vIGNvbm5lY3RlZCA9IHNvY2tldCBvcGVuZWQgKyBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlpbmcgPSBmYWxzZTsgLy8gZnV0dXJlIGxhenkgY29ubmVjdHMgYXJlIG5vdCByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXMgPSAwOyAvLyByZXNldCB0aGUgcmV0cmllcyBvbiBjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZChbXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBlcnJvck9yQ2xvc2VkKHJlamVjdCkpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25tZXNzYWdlID0gbnVsbDsgLy8gc3RvcCByZWFkaW5nIG1lc3NhZ2VzIGFzIHNvb24gYXMgcmVhZGluZyBicmVha3Mgb25jZVxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKENsb3NlQ29kZS5CYWRSZXNwb25zZSwgbGltaXRDbG9zZVJlYXNvbihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogbmV3IEVycm9yKGVycikubWVzc2FnZSwgJ0JhZCByZXNwb25zZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpKSkpO1xuICAgICAgICAvLyBpZiB0aGUgcHJvdmlkZWQgc29ja2V0IGlzIGluIGEgY2xvc2luZyBzdGF0ZSwgd2FpdCBmb3IgdGhlIHRocm93IG9uIGNsb3NlXG4gICAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5DTE9TSU5HKVxuICAgICAgICAgICAgYXdhaXQgdGhyb3dPbkNsb3NlO1xuICAgICAgICBsZXQgcmVsZWFzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlbGVhc2VzIHRoaXMgY29ubmVjdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAocmVsZWFzZSA9IHJlc29sdmUpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIHJlbGVhc2UsXG4gICAgICAgICAgICBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yXG4gICAgICAgICAgICAgICAgcmVsZWFzZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9ja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBubyBtb3JlIGxvY2tzIGFyZSBwcmVzZW50LCBjb21wbGV0ZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiBzb2NrZXQuY2xvc2UoMTAwMCwgJ05vcm1hbCBDbG9zdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaW5pdGUobGF6eUNsb3NlVGltZW91dE1zKSAmJiBsYXp5Q2xvc2VUaW1lb3V0TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGtlZXBhbGl2ZSBpcyBzZXQsIGFsbG93IGZvciB0aGUgc3BlY2lmaWVkIGNhbG1kb3duIHRpbWUgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBjb21wbGV0ZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIG9wZW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF6eUNsb3NlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldEltcGwuT1BFTilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGF6eUNsb3NlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjb21wbGV0ZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAvLyBvclxuICAgICAgICAgICAgICAgIHRocm93T25DbG9zZSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGBjb25uZWN0YCBwcm9ibGVtIGFuZCBldmFsdWF0ZXMgaWYgdGhlIGNsaWVudCBzaG91bGQgcmV0cnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkUmV0cnlDb25uZWN0T3JUaHJvdyhlcnJPckNsb3NlRXZlbnQpIHtcbiAgICAgICAgLy8gc29tZSBjbG9zZSBjb2RlcyBhcmUgd29ydGggcmVwb3J0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0xpa2VDbG9zZUV2ZW50KGVyck9yQ2xvc2VFdmVudCkgJiZcbiAgICAgICAgICAgIChpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoZXJyT3JDbG9zZUV2ZW50LmNvZGUpIHx8XG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLkludGVybmFsQ2xpZW50RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5CYWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuQmFkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5VbmF1dGhvcml6ZWQsXG4gICAgICAgICAgICAgICAgICAgIC8vIENsb3NlQ29kZS5Gb3JiaWRkZW4sIG1pZ2h0IGdyYW50IGFjY2VzcyBvdXQgYWZ0ZXIgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgQ2xvc2VDb2RlLlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2VDb2RlLkNvbm5lY3Rpb25Jbml0aWFsaXNhdGlvblRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZUNvZGUuQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQsIG1pZ2h0IG5vdCB0aW1lIG91dCBhZnRlciByZXRyeVxuICAgICAgICAgICAgICAgICAgICBDbG9zZUNvZGUuU3Vic2NyaWJlckFscmVhZHlFeGlzdHMsXG4gICAgICAgICAgICAgICAgICAgIENsb3NlQ29kZS5Ub29NYW55SW5pdGlhbGlzYXRpb25SZXF1ZXN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gNDQ5OSwgLy8gVGVybWluYXRlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgc29ja2V0IGZyb3plLCB3ZSB3YW50IHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnJPckNsb3NlRXZlbnQuY29kZSkpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBjbGllbnQgd2FzIGRpc3Bvc2VkLCBubyByZXRyaWVzIHNob3VsZCBwcm9jZWVkIHJlZ2FyZGxlc3NcbiAgICAgICAgaWYgKGRpc3Bvc2VkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBub3JtYWwgY2xvc3VyZSAocG9zc2libHkgYWxsIHN1YnNjcmlwdGlvbnMgaGF2ZSBjb21wbGV0ZWQpXG4gICAgICAgIC8vIGlmIG5vIGxvY2tzIHdlcmUgYWNxdWlyZWQgaW4gdGhlIG1lYW50aW1lLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgaWYgKGlzTGlrZUNsb3NlRXZlbnQoZXJyT3JDbG9zZUV2ZW50KSAmJiBlcnJPckNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBsb2NrcyA+IDA7XG4gICAgICAgIC8vIHJldHJpZXMgYXJlIG5vdCBhbGxvd2VkIG9yIHdlIHRyaWVkIHRvIG1hbnkgdGltZXMsIHJlcG9ydCBlcnJvclxuICAgICAgICBpZiAoIXJldHJ5QXR0ZW1wdHMgfHwgcmV0cmllcyA+PSByZXRyeUF0dGVtcHRzKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyB0aHJvdyBub24tcmV0cnlhYmxlIGNvbm5lY3Rpb24gcHJvYmxlbXNcbiAgICAgICAgaWYgKCFzaG91bGRSZXRyeShlcnJPckNsb3NlRXZlbnQpKVxuICAgICAgICAgICAgdGhyb3cgZXJyT3JDbG9zZUV2ZW50O1xuICAgICAgICAvLyBAZGVwcmVjYXRlZCB0aHJvdyBmYXRhbCBjb25uZWN0aW9uIHByb2JsZW1zIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0gPT09IG51bGwgfHwgaXNGYXRhbENvbm5lY3Rpb25Qcm9ibGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0oZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgIHRocm93IGVyck9yQ2xvc2VFdmVudDtcbiAgICAgICAgLy8gbG9va3MgZ29vZCwgc3RhcnQgcmV0cnlpbmdcbiAgICAgICAgcmV0dXJuIChyZXRyeWluZyA9IHRydWUpO1xuICAgIH1cbiAgICAvLyBpbiBub24tbGF6eSAoaG90PykgbW9kZSBhbHdheXMgaG9sZCBvbmUgY29ubmVjdGlvbiBsb2NrIHRvIHBlcnNpc3QgdGhlIHNvY2tldFxuICAgIGlmICghbGF6eSkge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCAsIHRocm93T25DbG9zZV0gPSBhd2FpdCBjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRocm93T25DbG9zZTsgLy8gd2lsbCBhbHdheXMgdGhyb3cgYmVjYXVzZSByZWxlYXNlciBpcyBub3QgdXNlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyT3JDbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwb3J0IHRocm93biBlcnJvciwgbm8gZnVydGhlciByZXRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25Ob25MYXp5RXJyb3IgPT09IG51bGwgfHwgb25Ob25MYXp5RXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTm9uTGF6eUVycm9yKGVyck9yQ2xvc2VFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZShwYXlsb2FkLCBzaW5rKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJRChwYXlsb2FkKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZSwgZXJyb3JlZCA9IGZhbHNlLCByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZvciBoYW5kbGluZyBjb21wbGV0aW9ucyBiZWZvcmUgY29ubmVjdFxuICAgICAgICAgICAgbG9ja3MtLTtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9ja3MrKztcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbc29ja2V0LCByZWxlYXNlLCB3YWl0Rm9yUmVsZWFzZU9yVGhyb3dPbkNsb3NlXSA9IGF3YWl0IGNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZG9uZSB3aGlsZSB3YWl0aW5nIGZvciBjb25uZWN0LCByZWxlYXNlIHRoZSBjb25uZWN0aW9uIGxvY2sgcmlnaHQgYXdheVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVubGlzdGVuID0gZW1pdHRlci5vbk1lc3NhZ2UoaWQsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTmV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBwYXlsb2FkIHdpbGwgZml0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5uZXh0KG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3JlZCA9IHRydWUpLCAoZG9uZSA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmVycm9yKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db21wbGV0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXIoKTsgLy8gcmVsZWFzZSBjb21wbGV0ZXMgdGhlIHNpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TdWJzY3JpYmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9LCByZXBsYWNlcikpO1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0SW1wbC5PUEVOKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBjb21wbGV0ZWQgYWxyZWFkeSBhbmQgc29ja2V0IGlzIG9wZW4sIHNlbmQgY29tcGxldGUgbWVzc2FnZSB0byBzZXJ2ZXIgb24gcmVsZWFzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHN0cmluZ2lmeU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVwbGFjZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2tzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWl0aGVyIHRoZSByZWxlYXNlciB3aWxsIGJlIGNhbGxlZCwgY29ubmVjdGlvbiBjb21wbGV0ZWQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9taXNlIHJlc29sdmVkIG9yIHRoZSBzb2NrZXQgY2xvc2VkIGFuZCB0aGUgcHJvbWlzZSByZWplY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hhdGV2ZXIgaGFwcGVucyB0aG91Z2gsIHdlIHdhbnQgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JSZWxlYXNlT3JUaHJvd09uQ2xvc2UuZmluYWxseSh1bmxpc3Rlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY29tcGxldGVkLCBzaG91bGRudCB0cnkgYWdhaW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVyck9yQ2xvc2VFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3coZXJyT3JDbG9zZUV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGRlbGl2ZXJpbmcgZWl0aGVyIGFuIGVycm9yIG9yIGEgY29tcGxldGUgdGVybWluYXRlcyB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIGlmICghZXJyb3JlZClcbiAgICAgICAgICAgICAgICBzaW5rLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pIC8vIHJlc29sdmVzIG9uIHJlbGVhc2Ugb3Igbm9ybWFsIGNsb3N1cmVcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH0pOyAvLyByZWplY3RzIG9uIGNsb3NlIGV2ZW50cyBhbmQgZXJyb3JzXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBkaXNwb3NlIG9ubHkgb2YgYWN0aXZlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZWxlYXNlcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvbjogZW1pdHRlci5vbixcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBpdGVyYXRlKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0ge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zZSA9IHN1YnNjcmliZShyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gcGF5bG9hZCB3aWxsIGZpdCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IChmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyYXRvcl8xKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSB3YWl0IGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nIG1lc3NhZ2VzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IChkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZsdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocGVuZGluZy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZlcnJlZC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlZmVycmVkLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZlcnJlZC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLnRocm93ID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGVmZXJyZWQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uLCBjbG9zZSBpdFxuICAgICAgICAgICAgICAgIGNvbnN0IFtzb2NrZXRdID0gYXdhaXQgY29ubmVjdGluZztcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoMTAwMCwgJ05vcm1hbCBDbG9zdXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBpZiB0aGVyZSBpcyBhIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2Nsb3NlZCcsIG5ldyBUZXJtaW5hdGVkQ2xvc2VFdmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBBIHN5bnRoZXRpYyBjbG9zZSBldmVudCBgNDQ5OTogVGVybWluYXRlZGAgaXMgaXNzdWVkIHRvIHRoZSBjdXJyZW50IHRvIGltbWVkaWF0ZWx5XG4gKiBjbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvbmUgY29taW5nIGZyb20gYFdlYlNvY2tldC5vbmNsb3NlYC5cbiAqXG4gKiBUZXJtaW5hdGluZyBpcyBub3QgY29uc2lkZXJlZCBmYXRhbCBhbmQgYSBjb25uZWN0aW9uIHJldHJ5IHdpbGwgb2NjdXIgYXMgZXhwZWN0ZWQuXG4gKlxuICogVXNlZnVsIGluIGNhc2VzIHdoZXJlIHRoZSBXZWJTb2NrZXQgaXMgc3R1Y2sgYW5kIG5vdCBlbWl0dGluZyBhbnkgZXZlbnRzO1xuICogY2FuIGhhcHBlbiBvbiBpT1MgU2FmYXJpLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbmlzZGVuam8vZ3JhcGhxbC13cy9kaXNjdXNzaW9ucy8yOTAuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXJtaW5hdGVkQ2xvc2VFdmVudCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rlcm1pbmF0ZWRDbG9zZUV2ZW50JztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJzQ0OTk6IFRlcm1pbmF0ZWQnO1xuICAgICAgICB0aGlzLmNvZGUgPSA0NDk5O1xuICAgICAgICB0aGlzLnJlYXNvbiA9ICdUZXJtaW5hdGVkJztcbiAgICAgICAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTGlrZUNsb3NlRXZlbnQodmFsKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgJ2NvZGUnIGluIHZhbCAmJiAncmVhc29uJyBpbiB2YWw7XG59XG5mdW5jdGlvbiBpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUoY29kZSkge1xuICAgIGlmIChbXG4gICAgICAgIDEwMDAsIC8vIE5vcm1hbCBDbG9zdXJlIGlzIG5vdCBhbiBlcnJvbmVvdXMgY2xvc2UgY29kZVxuICAgICAgICAxMDAxLCAvLyBHb2luZyBBd2F5XG4gICAgICAgIDEwMDYsIC8vIEFibm9ybWFsIENsb3N1cmVcbiAgICAgICAgMTAwNSwgLy8gTm8gU3RhdHVzIFJlY2VpdmVkXG4gICAgICAgIDEwMTIsIC8vIFNlcnZpY2UgUmVzdGFydFxuICAgICAgICAxMDEzLCAvLyBUcnkgQWdhaW4gTGF0ZXJcbiAgICAgICAgMTAxNCwgLy8gQmFkIEdhdGV3YXlcbiAgICBdLmluY2x1ZGVzKGNvZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWxsIG90aGVyIGludGVybmFsIGVycm9ycyBhcmUgZmF0YWxcbiAgICByZXR1cm4gY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gMTk5OTtcbn1cbmZ1bmN0aW9uIGlzV2ViU29ja2V0KHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAnY29uc3RydWN0b3InIGluIHZhbCAmJlxuICAgICAgICAnQ0xPU0VEJyBpbiB2YWwgJiZcbiAgICAgICAgJ0NMT1NJTkcnIGluIHZhbCAmJlxuICAgICAgICAnQ09OTkVDVElORycgaW4gdmFsICYmXG4gICAgICAgICdPUEVOJyBpbiB2YWwpO1xufVxuIl0sIm5hbWVzIjpbIl9fYXdhaXQiLCJ2IiwiX19hc3luY0dlbmVyYXRvciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiZ2VuZXJhdG9yIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsIlR5cGVFcnJvciIsImciLCJhcHBseSIsImkiLCJxIiwiT2JqZWN0IiwiY3JlYXRlIiwiQXN5bmNJdGVyYXRvciIsInByb3RvdHlwZSIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJyZWplY3QiLCJuIiwiYSIsImIiLCJwdXNoIiwicmVzdW1lIiwic3RlcCIsImUiLCJzZXR0bGUiLCJyIiwidmFsdWUiLCJmdWxmaWxsIiwic2hpZnQiLCJsZW5ndGgiLCJDbG9zZUNvZGUiLCJHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCIsIk1lc3NhZ2VUeXBlIiwicGFyc2VNZXNzYWdlIiwic3RyaW5naWZ5TWVzc2FnZSIsImlzT2JqZWN0IiwibGltaXRDbG9zZVJlYXNvbiIsImNyZWF0ZUNsaWVudCIsIm9wdGlvbnMiLCJ1cmwiLCJjb25uZWN0aW9uUGFyYW1zIiwibGF6eSIsIm9uTm9uTGF6eUVycm9yIiwiY29uc29sZSIsImVycm9yIiwibGF6eUNsb3NlVGltZW91dCIsImxhenlDbG9zZVRpbWVvdXRNcyIsImtlZXBBbGl2ZSIsImRpc2FibGVQb25nIiwiY29ubmVjdGlvbkFja1dhaXRUaW1lb3V0IiwicmV0cnlBdHRlbXB0cyIsInJldHJ5V2FpdCIsInJhbmRvbWlzZWRFeHBvbmVudGlhbEJhY2tvZmYiLCJyZXRyaWVzIiwicmV0cnlEZWxheSIsInNldFRpbWVvdXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJzaG91bGRSZXRyeSIsImlzTGlrZUNsb3NlRXZlbnQiLCJpc0ZhdGFsQ29ubmVjdGlvblByb2JsZW0iLCJvbiIsIndlYlNvY2tldEltcGwiLCJnZW5lcmF0ZUlEIiwiZ2VuZXJhdGVVVUlEIiwicmVwbGFjZSIsImMiLCJ0b1N0cmluZyIsImpzb25NZXNzYWdlUmVwbGFjZXIiLCJyZXBsYWNlciIsImpzb25NZXNzYWdlUmV2aXZlciIsInJldml2ZXIiLCJ3cyIsImlzV2ViU29ja2V0IiwiRXJyb3IiLCJXZWJTb2NrZXQiLCJnbG9iYWwiLCJNb3pXZWJTb2NrZXQiLCJ3aW5kb3ciLCJXZWJTb2NrZXRJbXBsIiwiZW1pdHRlciIsIm1lc3NhZ2UiLCJsaXN0ZW5lcnMiLCJpZCIsImxpc3RlbmVyIiwiZW1pdCIsIl9hIiwiY2FsbCIsImNvbm5lY3RpbmciLCJvcGVuZWQiLCJjb25uZWN0ZWQiLCJwaW5nIiwicG9uZyIsImNsb3NlZCIsIm9uTWVzc2FnZSIsImV2ZW50IiwibCIsInNwbGljZSIsImluZGV4T2YiLCJhcmdzIiwiZXJyb3JPckNsb3NlZCIsImNiIiwibGlzdGVuaW5nIiwiZXJyIiwiZm9yRWFjaCIsInVubGlzdGVuIiwibG9ja3MiLCJyZXRyeWluZyIsImRpc3Bvc2VkIiwiY29ubmVjdCIsImNsZWFyVGltZW91dCIsInNvY2tldCIsInRocm93T25DbG9zZSIsImRlbmllZCIsInVuZGVmaW5lZCIsImNvZGUiLCJyZWFzb24iLCJjb25uZWN0aW9uQWNrVGltZW91dCIsInF1ZXVlZFBpbmciLCJlbnF1ZXVlUGluZyIsImlzRmluaXRlIiwicmVhZHlTdGF0ZSIsIk9QRU4iLCJzZW5kIiwidHlwZSIsIlBpbmciLCJlcnJPckV2ZW50IiwiVGVybWluYXRlZENsb3NlRXZlbnQiLCJjbG9zZSIsIm9uZXJyb3IiLCJvbmNsb3NlIiwib25vcGVuIiwicGF5bG9hZCIsIkNvbm5lY3Rpb25Jbml0IiwiQ29ubmVjdGlvbkFja25vd2xlZGdlbWVudFRpbWVvdXQiLCJJbnRlcm5hbENsaWVudEVycm9yIiwiYWNrbm93bGVkZ2VkIiwib25tZXNzYWdlIiwiZGF0YSIsIlBvbmciLCJDb25uZWN0aW9uQWNrIiwiXyIsIkJhZFJlc3BvbnNlIiwiQ0xPU0lORyIsInJlbGVhc2UiLCJyZWxlYXNlZCIsInJhY2UiLCJjb21wbGV0ZSIsInNob3VsZFJldHJ5Q29ubmVjdE9yVGhyb3ciLCJlcnJPckNsb3NlRXZlbnQiLCJpc0ZhdGFsSW50ZXJuYWxDbG9zZUNvZGUiLCJJbnRlcm5hbFNlcnZlckVycm9yIiwiQmFkUmVxdWVzdCIsIlVuYXV0aG9yaXplZCIsIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZSIsIlN1YnNjcmliZXJBbHJlYWR5RXhpc3RzIiwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHMiLCJpbmNsdWRlcyIsInN1YnNjcmliZSIsInNpbmsiLCJkb25lIiwiZXJyb3JlZCIsInJlbGVhc2VyIiwid2FpdEZvclJlbGVhc2VPclRocm93T25DbG9zZSIsIk5leHQiLCJuZXh0IiwiQ29tcGxldGUiLCJTdWJzY3JpYmUiLCJmaW5hbGx5IiwiY2F0Y2giLCJpdGVyYXRlIiwicmVxdWVzdCIsInBlbmRpbmciLCJkZWZlcnJlZCIsImRpc3Bvc2UiLCJ2YWwiLCJpdGVyYXRvciIsImFyZ3VtZW50cyIsIml0ZXJhdG9yXzEiLCJ0aHJvdyIsInJldHVybiIsInRlcm1pbmF0ZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIndhc0NsZWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/client.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/common.mjs":
/*!************************************************!*\
  !*** ./node_modules/graphql-ws/lib/common.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CloseCode: () => (/* binding */ CloseCode),\n/* harmony export */   DEPRECATED_GRAPHQL_WS_PROTOCOL: () => (/* binding */ DEPRECATED_GRAPHQL_WS_PROTOCOL),\n/* harmony export */   GRAPHQL_TRANSPORT_WS_PROTOCOL: () => (/* binding */ GRAPHQL_TRANSPORT_WS_PROTOCOL),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   isMessage: () => (/* binding */ isMessage),\n/* harmony export */   parseMessage: () => (/* binding */ parseMessage),\n/* harmony export */   stringifyMessage: () => (/* binding */ stringifyMessage),\n/* harmony export */   validateMessage: () => (/* binding */ validateMessage)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/graphql-ws/lib/utils.mjs\");\n/**\n *\n * common\n *\n */ \n/**\n * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */ const GRAPHQL_TRANSPORT_WS_PROTOCOL = \"graphql-transport-ws\";\n/**\n * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n *\n * @private\n */ const DEPRECATED_GRAPHQL_WS_PROTOCOL = \"graphql-ws\";\n/**\n * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](https://github.com/graphql/graphql-over-http/blob/main/rfcs/GraphQLOverWebSocket.md).\n *\n * @category Common\n */ var CloseCode;\n(function(CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */ CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */ CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n})(CloseCode || (CloseCode = {}));\n/**\n * Types of messages allowed to be sent by the client/server over the WS protocol.\n *\n * @category Common\n */ var MessageType;\n(function(MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n})(MessageType || (MessageType = {}));\n/**\n * Validates the message against the GraphQL over WebSocket Protocol.\n *\n * Invalid messages will throw descriptive errors.\n *\n * @category Common\n */ function validateMessage(val) {\n    if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val)) {\n        throw new Error(`Message is expected to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val)}`);\n    }\n    if (!val.type) {\n        throw new Error(`Message is missing the 'type' property`);\n    }\n    if (typeof val.type !== \"string\") {\n        throw new Error(`Message is expects the 'type' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.type)}`);\n    }\n    switch(val.type){\n        case MessageType.ConnectionInit:\n        case MessageType.ConnectionAck:\n        case MessageType.Ping:\n        case MessageType.Pong:\n            {\n                if (val.payload != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object or nullish or missing, but got \"${val.payload}\"`);\n                }\n                break;\n            }\n        case MessageType.Subscribe:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n                }\n                if (typeof val.payload.query !== \"string\") {\n                    throw new Error(`\"${val.type}\" message payload expects the 'query' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.query)}`);\n                }\n                if (val.payload.variables != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.variables)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.variables)}`);\n                }\n                if (val.payload.operationName != null && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName) !== \"string\") {\n                    throw new Error(`\"${val.type}\" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.operationName)}`);\n                }\n                if (val.payload.extensions != null && !(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload.extensions)) {\n                    throw new Error(`\"${val.type}\" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload.extensions)}`);\n                }\n                break;\n            }\n        case MessageType.Next:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an object, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.payload)}`);\n                }\n                break;\n            }\n        case MessageType.Error:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                if (!(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.areGraphQLErrors)(val.payload)) {\n                    throw new Error(`\"${val.type}\" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(val.payload)}`);\n                }\n                break;\n            }\n        case MessageType.Complete:\n            {\n                if (typeof val.id !== \"string\") {\n                    throw new Error(`\"${val.type}\" message expects the 'id' property to be a string, but got ${(0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.extendedTypeof)(val.id)}`);\n                }\n                if (!val.id) {\n                    throw new Error(`\"${val.type}\" message requires a non-empty 'id' property`);\n                }\n                break;\n            }\n        default:\n            throw new Error(`Invalid message 'type' property \"${val.type}\"`);\n    }\n    return val;\n}\n/**\n * Checks if the provided value is a valid GraphQL over WebSocket message.\n *\n * @deprecated Use `validateMessage` instead.\n *\n * @category Common\n */ function isMessage(val) {\n    try {\n        validateMessage(val);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Parses the raw websocket message data to a valid message.\n *\n * @category Common\n */ function parseMessage(data, reviver) {\n    return validateMessage(typeof data === \"string\" ? JSON.parse(data, reviver) : data);\n}\n/**\n * Stringifies a valid message ready to be sent through the socket.\n *\n * @category Common\n */ function stringifyMessage(msg, replacer) {\n    validateMessage(msg);\n    return JSON.stringify(msg, replacer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvY29tbW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ3dFO0FBQ3pFOzs7O0NBSUMsR0FDTSxNQUFNRyxnQ0FBZ0MsdUJBQXVCO0FBQ3BFOzs7O0NBSUMsR0FDTSxNQUFNQyxpQ0FBaUMsYUFBYTtBQUMzRDs7OztDQUlDLEdBQ00sSUFBSUMsVUFBVTtBQUNwQixVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxzQkFBc0IsR0FBRyxLQUFLLEdBQUc7SUFDckRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHNCQUFzQixHQUFHLEtBQUssR0FBRztJQUNyREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsYUFBYSxHQUFHLEtBQUssR0FBRztJQUM1Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLEtBQUssR0FBRztJQUM3Qyx5Q0FBeUMsR0FDekNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGVBQWUsR0FBRyxLQUFLLEdBQUc7SUFDOUNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFlBQVksR0FBRyxLQUFLLEdBQUc7SUFDM0NBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDJCQUEyQixHQUFHLEtBQUssR0FBRztJQUMxREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsa0NBQWtDLEdBQUcsS0FBSyxHQUFHO0lBQ2pFQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxtQ0FBbUMsR0FBRyxLQUFLLEdBQUc7SUFDbEUsNkNBQTZDLEdBQzdDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQywwQkFBMEIsR0FBRyxLQUFLLEdBQUc7SUFDekRBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGdDQUFnQyxHQUFHLEtBQUssR0FBRztBQUNuRSxHQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDOUI7Ozs7Q0FJQyxHQUNNLElBQUlDLFlBQVk7QUFDdEIsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFD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QixTQUFTLFdBQVdOLEtBQUtRLEtBQUssQ0FBQ0YsTUFBTUMsV0FBV0Q7QUFDbEY7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0csaUJBQWlCQyxHQUFHLEVBQUVDLFFBQVE7SUFDMUMzQixnQkFBZ0IwQjtJQUNoQixPQUFPVixLQUFLQyxTQUFTLENBQUNTLEtBQUtDO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hlcmVua292LXdlYi8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi9jb21tb24ubWpzPzA2MTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKlxuICogY29tbW9uXG4gKlxuICovXG5pbXBvcnQgeyBhcmVHcmFwaFFMRXJyb3JzLCBleHRlbmRlZFR5cGVvZiwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG4vKipcbiAqIFRoZSBXZWJTb2NrZXQgc3ViLXByb3RvY29sIHVzZWQgZm9yIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGNvbnN0IEdSQVBIUUxfVFJBTlNQT1JUX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtdHJhbnNwb3J0LXdzJztcbi8qKlxuICogVGhlIGRlcHJlY2F0ZWQgc3VicHJvdG9jb2wgdXNlZCBieSBbc3Vic2NyaXB0aW9ucy10cmFuc3BvcnQtd3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9hcG9sbG9ncmFwaHFsL3N1YnNjcmlwdGlvbnMtdHJhbnNwb3J0LXdzKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgREVQUkVDQVRFRF9HUkFQSFFMX1dTX1BST1RPQ09MID0gJ2dyYXBocWwtd3MnO1xuLyoqXG4gKiBgZ3JhcGhxbC13c2AgZXhwZWN0ZWQgYW5kIHN0YW5kYXJkIGNsb3NlIGNvZGVzIG9mIHRoZSBbR3JhcGhRTCBvdmVyIFdlYlNvY2tldCBQcm90b2NvbF0oaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1vdmVyLWh0dHAvYmxvYi9tYWluL3JmY3MvR3JhcGhRTE92ZXJXZWJTb2NrZXQubWQpLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBDbG9zZUNvZGU7XG4oZnVuY3Rpb24gKENsb3NlQ29kZSkge1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJJbnRlcm5hbFNlcnZlckVycm9yXCJdID0gNDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiSW50ZXJuYWxDbGllbnRFcnJvclwiXSA9IDQwMDVdID0gXCJJbnRlcm5hbENsaWVudEVycm9yXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkJhZFJlcXVlc3RcIl0gPSA0NDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJCYWRSZXNwb25zZVwiXSA9IDQwMDRdID0gXCJCYWRSZXNwb25zZVwiO1xuICAgIC8qKiBUcmllZCBzdWJzY3JpYmluZyBiZWZvcmUgY29ubmVjdCBhY2sgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVW5hdXRob3JpemVkXCJdID0gNDQwMV0gPSBcIlVuYXV0aG9yaXplZFwiO1xuICAgIENsb3NlQ29kZVtDbG9zZUNvZGVbXCJGb3JiaWRkZW5cIl0gPSA0NDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIlN1YnByb3RvY29sTm90QWNjZXB0YWJsZVwiXSA9IDQ0MDZdID0gXCJTdWJwcm90b2NvbE5vdEFjY2VwdGFibGVcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiQ29ubmVjdGlvbkluaXRpYWxpc2F0aW9uVGltZW91dFwiXSA9IDQ0MDhdID0gXCJDb25uZWN0aW9uSW5pdGlhbGlzYXRpb25UaW1lb3V0XCI7XG4gICAgQ2xvc2VDb2RlW0Nsb3NlQ29kZVtcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCJdID0gNDUwNF0gPSBcIkNvbm5lY3Rpb25BY2tub3dsZWRnZW1lbnRUaW1lb3V0XCI7XG4gICAgLyoqIFN1YnNjcmliZXIgZGlzdGluY3Rpb24gaXMgdmVyeSBpbXBvcnRhbnQgKi9cbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIl0gPSA0NDA5XSA9IFwiU3Vic2NyaWJlckFscmVhZHlFeGlzdHNcIjtcbiAgICBDbG9zZUNvZGVbQ2xvc2VDb2RlW1wiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIl0gPSA0NDI5XSA9IFwiVG9vTWFueUluaXRpYWxpc2F0aW9uUmVxdWVzdHNcIjtcbn0pKENsb3NlQ29kZSB8fCAoQ2xvc2VDb2RlID0ge30pKTtcbi8qKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgYWxsb3dlZCB0byBiZSBzZW50IGJ5IHRoZSBjbGllbnQvc2VydmVyIG92ZXIgdGhlIFdTIHByb3RvY29sLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IHZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25Jbml0XCJdID0gXCJjb25uZWN0aW9uX2luaXRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIkNvbm5lY3Rpb25BY2tcIl0gPSBcImNvbm5lY3Rpb25fYWNrXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQaW5nXCJdID0gXCJwaW5nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQb25nXCJdID0gXCJwb25nXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJTdWJzY3JpYmVcIl0gPSBcInN1YnNjcmliZVwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiTmV4dFwiXSA9IFwibmV4dFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJDb21wbGV0ZVwiXSA9IFwiY29tcGxldGVcIjtcbn0pKE1lc3NhZ2VUeXBlIHx8IChNZXNzYWdlVHlwZSA9IHt9KSk7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgbWVzc2FnZSBhZ2FpbnN0IHRoZSBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IFByb3RvY29sLlxuICpcbiAqIEludmFsaWQgbWVzc2FnZXMgd2lsbCB0aHJvdyBkZXNjcmlwdGl2ZSBlcnJvcnMuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlKHZhbCkge1xuICAgIGlmICghaXNPYmplY3QodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsKX1gKTtcbiAgICB9XG4gICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lc3NhZ2UgaXMgbWlzc2luZyB0aGUgJ3R5cGUnIHByb3BlcnR5YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBpcyBleHBlY3RzIHRoZSAndHlwZScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwudHlwZSl9YCk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsLnR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uSW5pdDpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5Db25uZWN0aW9uQWNrOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBpbmc6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUG9uZzoge1xuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCBvciBudWxsaXNoIG9yIG1pc3NpbmcsIGJ1dCBnb3QgXCIke3ZhbC5wYXlsb2FkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlN1YnNjcmliZToge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbC5wYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3ZhbC50eXBlfVwiIG1lc3NhZ2UgZXhwZWN0cyB0aGUgJ3BheWxvYWQnIHByb3BlcnR5IHRvIGJlIGFuIG9iamVjdCwgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnBheWxvYWQucXVlcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBwYXlsb2FkIGV4cGVjdHMgdGhlICdxdWVyeScgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5xdWVyeSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnBheWxvYWQudmFyaWFibGVzICE9IG51bGwgJiYgIWlzT2JqZWN0KHZhbC5wYXlsb2FkLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ3ZhcmlhYmxlcycgcHJvcGVydHkgdG8gYmUgYSBhbiBvYmplY3Qgb3IgbnVsbGlzaCBvciBtaXNzaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQudmFyaWFibGVzKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBleHRlbmRlZFR5cGVvZih2YWwucGF5bG9hZC5vcGVyYXRpb25OYW1lKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ29wZXJhdGlvbk5hbWUnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nIG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLm9wZXJhdGlvbk5hbWUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMgIT0gbnVsbCAmJiAhaXNPYmplY3QodmFsLnBheWxvYWQuZXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHBheWxvYWQgZXhwZWN0cyB0aGUgJ2V4dGVuc2lvbnMnIHByb3BlcnR5IHRvIGJlIGEgYW4gb2JqZWN0IG9yIG51bGxpc2ggb3IgbWlzc2luZywgYnV0IGdvdCAke2V4dGVuZGVkVHlwZW9mKHZhbC5wYXlsb2FkLmV4dGVuc2lvbnMpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5OZXh0OiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNPYmplY3QodmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gb2JqZWN0LCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLnBheWxvYWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5FcnJvcjoge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAnaWQnIHByb3BlcnR5IHRvIGJlIGEgc3RyaW5nLCBidXQgZ290ICR7ZXh0ZW5kZWRUeXBlb2YodmFsLmlkKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSByZXF1aXJlcyBhIG5vbi1lbXB0eSAnaWQnIHByb3BlcnR5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZUdyYXBoUUxFcnJvcnModmFsLnBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsLnR5cGV9XCIgbWVzc2FnZSBleHBlY3RzIHRoZSAncGF5bG9hZCcgcHJvcGVydHkgdG8gYmUgYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwucGF5bG9hZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkNvbXBsZXRlOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIGV4cGVjdHMgdGhlICdpZCcgcHJvcGVydHkgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgJHtleHRlbmRlZFR5cGVvZih2YWwuaWQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWwuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWwudHlwZX1cIiBtZXNzYWdlIHJlcXVpcmVzIGEgbm9uLWVtcHR5ICdpZCcgcHJvcGVydHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSAndHlwZScgcHJvcGVydHkgXCIke3ZhbC50eXBlfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSB2YWxpZCBHcmFwaFFMIG92ZXIgV2ViU29ja2V0IG1lc3NhZ2UuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB2YWxpZGF0ZU1lc3NhZ2VgIGluc3RlYWQuXG4gKlxuICogQGNhdGVnb3J5IENvbW1vblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKHZhbCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlTWVzc2FnZSh2YWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgcmF3IHdlYnNvY2tldCBtZXNzYWdlIGRhdGEgdG8gYSB2YWxpZCBtZXNzYWdlLlxuICpcbiAqIEBjYXRlZ29yeSBDb21tb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShkYXRhLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTWVzc2FnZSh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGRhdGEsIHJldml2ZXIpIDogZGF0YSk7XG59XG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgdmFsaWQgbWVzc2FnZSByZWFkeSB0byBiZSBzZW50IHRocm91Z2ggdGhlIHNvY2tldC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlNZXNzYWdlKG1zZywgcmVwbGFjZXIpIHtcbiAgICB2YWxpZGF0ZU1lc3NhZ2UobXNnKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobXNnLCByZXBsYWNlcik7XG59XG4iXSwibmFtZXMiOlsiYXJlR3JhcGhRTEVycm9ycyIsImV4dGVuZGVkVHlwZW9mIiwiaXNPYmplY3QiLCJHUkFQSFFMX1RSQU5TUE9SVF9XU19QUk9UT0NPTCIsIkRFUFJFQ0FURURfR1JBUEhRTF9XU19QUk9UT0NPTCIsIkNsb3NlQ29kZSIsIk1lc3NhZ2VUeXBlIiwidmFsaWRhdGVNZXNzYWdlIiwidmFsIiwiRXJyb3IiLCJ0eXBlIiwiQ29ubmVjdGlvbkluaXQiLCJDb25uZWN0aW9uQWNrIiwiUGluZyIsIlBvbmciLCJwYXlsb2FkIiwiU3Vic2NyaWJlIiwiaWQiLCJxdWVyeSIsInZhcmlhYmxlcyIsIm9wZXJhdGlvbk5hbWUiLCJleHRlbnNpb25zIiwiTmV4dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJDb21wbGV0ZSIsImlzTWVzc2FnZSIsIl9hIiwicGFyc2VNZXNzYWdlIiwiZGF0YSIsInJldml2ZXIiLCJwYXJzZSIsInN0cmluZ2lmeU1lc3NhZ2UiLCJtc2ciLCJyZXBsYWNlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/common.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphql-ws/lib/utils.mjs":
/*!***********************************************!*\
  !*** ./node_modules/graphql-ws/lib/utils.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areGraphQLErrors: () => (/* binding */ areGraphQLErrors),\n/* harmony export */   extendedTypeof: () => (/* binding */ extendedTypeof),\n/* harmony export */   isAsyncGenerator: () => (/* binding */ isAsyncGenerator),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   limitCloseReason: () => (/* binding */ limitCloseReason)\n/* harmony export */ });\n/** @private */ function extendedTypeof(val) {\n    if (val === null) {\n        return \"null\";\n    }\n    if (Array.isArray(val)) {\n        return \"array\";\n    }\n    return typeof val;\n}\n/** @private */ function isObject(val) {\n    return extendedTypeof(val) === \"object\";\n}\n/** @private */ function isAsyncIterable(val) {\n    return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\n/** @private */ function isAsyncGenerator(val) {\n    return isObject(val) && typeof Object(val)[Symbol.asyncIterator] === \"function\" && typeof val.return === \"function\";\n}\n/** @private */ function areGraphQLErrors(obj) {\n    return Array.isArray(obj) && // must be at least one error\n    obj.length > 0 && // error has at least a message\n    obj.every((ob)=>\"message\" in ob);\n}\n/**\n * Limits the WebSocket close event reason to not exceed a length of one frame.\n * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n *\n * @private\n */ function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC13cy9saWIvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLGFBQWEsR0FDTixTQUFTQSxlQUFlQyxHQUFHO0lBQzlCLElBQUlBLFFBQVEsTUFBTTtRQUNkLE9BQU87SUFDWDtJQUNBLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsTUFBTTtRQUNwQixPQUFPO0lBQ1g7SUFDQSxPQUFPLE9BQU9BO0FBQ2xCO0FBQ0EsYUFBYSxHQUNOLFNBQVNHLFNBQVNILEdBQUc7SUFDeEIsT0FBT0QsZUFBZUMsU0FBUztBQUNuQztBQUNBLGFBQWEsR0FDTixTQUFTSSxnQkFBZ0JKLEdBQUc7SUFDL0IsT0FBTyxPQUFPSyxPQUFPTCxJQUFJLENBQUNNLE9BQU9DLGFBQWEsQ0FBQyxLQUFLO0FBQ3hEO0FBQ0EsYUFBYSxHQUNOLFNBQVNDLGlCQUFpQlIsR0FBRztJQUNoQyxPQUFRRyxTQUFTSCxRQUNiLE9BQU9LLE9BQU9MLElBQUksQ0FBQ00sT0FBT0MsYUFBYSxDQUFDLEtBQUssY0FDN0MsT0FBT1AsSUFBSVMsTUFBTSxLQUFLO0FBSzlCO0FBQ0EsYUFBYSxHQUNOLFNBQVNDLGlCQUFpQkMsR0FBRztJQUNoQyxPQUFRVixNQUFNQyxPQUFPLENBQUNTLFFBQ2xCLDZCQUE2QjtJQUM3QkEsSUFBSUMsTUFBTSxHQUFHLEtBQ2IsK0JBQStCO0lBQy9CRCxJQUFJRSxLQUFLLENBQUMsQ0FBQ0MsS0FBTyxhQUFhQTtBQUN2QztBQUNBOzs7OztDQUtDLEdBQ00sU0FBU0MsaUJBQWlCQyxNQUFNLEVBQUVDLFdBQVc7SUFDaEQsT0FBT0QsT0FBT0osTUFBTSxHQUFHLE1BQU1JLFNBQVNDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hlcmVua292LXdlYi8uL25vZGVfbW9kdWxlcy9ncmFwaHFsLXdzL2xpYi91dGlscy5tanM/MzM0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRlZFR5cGVvZih2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgdmFsO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkVHlwZW9mKHZhbCkgPT09ICdvYmplY3QnO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgT2JqZWN0KHZhbClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcih2YWwpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgdHlwZW9mIE9iamVjdCh2YWwpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsLnJldHVybiA9PT0gJ2Z1bmN0aW9uJ1xuICAgIC8vIGZvciBsYXp5IG9uZXMsIHdlIG9ubHkgbmVlZCB0aGUgcmV0dXJuIGFueXdheVxuICAgIC8vIHR5cGVvZiB2YWwudGhyb3cgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbidcbiAgICApO1xufVxuLyoqIEBwcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gYXJlR3JhcGhRTEVycm9ycyhvYmopIHtcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICAgICAvLyBtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvclxuICAgICAgICBvYmoubGVuZ3RoID4gMCAmJlxuICAgICAgICAvLyBlcnJvciBoYXMgYXQgbGVhc3QgYSBtZXNzYWdlXG4gICAgICAgIG9iai5ldmVyeSgob2IpID0+ICdtZXNzYWdlJyBpbiBvYikpO1xufVxuLyoqXG4gKiBMaW1pdHMgdGhlIFdlYlNvY2tldCBjbG9zZSBldmVudCByZWFzb24gdG8gbm90IGV4Y2VlZCBhIGxlbmd0aCBvZiBvbmUgZnJhbWUuXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTUuMi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGltaXRDbG9zZVJlYXNvbihyZWFzb24sIHdoZW5Ub29Mb25nKSB7XG4gICAgcmV0dXJuIHJlYXNvbi5sZW5ndGggPCAxMjQgPyByZWFzb24gOiB3aGVuVG9vTG9uZztcbn1cbiJdLCJuYW1lcyI6WyJleHRlbmRlZFR5cGVvZiIsInZhbCIsIkFycmF5IiwiaXNBcnJheSIsImlzT2JqZWN0IiwiaXNBc3luY0l0ZXJhYmxlIiwiT2JqZWN0IiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsImlzQXN5bmNHZW5lcmF0b3IiLCJyZXR1cm4iLCJhcmVHcmFwaFFMRXJyb3JzIiwib2JqIiwibGVuZ3RoIiwiZXZlcnkiLCJvYiIsImxpbWl0Q2xvc2VSZWFzb24iLCJyZWFzb24iLCJ3aGVuVG9vTG9uZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphql-ws/lib/utils.mjs\n");

/***/ })

};
;